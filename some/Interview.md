### Мікросервіси

1. **Яка різниця між Monolith/SOA/Microservices?**

	Monolith- усе в одному великому застосунку — бізнес-логіка, UI, база даних, API.
	Одна кодова база, один деплой.
	Якщо потрібно змінити навіть дрібницю — потрібно перезбирати та перезапускати весь проєкт.
	Простий старт, але важко масштабувати та підтримувати з часом.
	
	
	**SOA (Service-Oriented Architecture)**
	Застосунок розбитий на сервіси, але вони часто “товсті” та важкі. Використовуються ESB (Enterprise Service Bus) — централізована шина, через яку все спілкується.
	Сервіси можуть мати спільну базу даних або залежати один від одного.
	Мінус: централізована шина стає “вузьким місцем”, а моноліт просто розмазаний по сервісах.
	
	**Microservices (Мікросервіси)**
	Кожна функціональність — окремий незалежний сервіс.
	Своя база, свій деплой, своя відповідальність (принцип _Single Responsibility_).
	Сервіси спілкуються через HTTP/gRPC/Message Brokers, але немає єдиного “центру” як ESB.
	Легко масштабувати — навантажений сервіс можна розгорнути в 10 копіях без впливу на інші.
	Ідеально для DevOps, CI/CD, Docker, Kubernetes.

| Архітектура       | Як виглядає                        | Основні плюси             | Основні мінуси               |
| ----------------- | ---------------------------------- | ------------------------- | ---------------------------- |
| **Monolith**      | Один великий застосунок            | Простий старт             | Погана масштабованість       |
| **SOA**           | Великі сервіси через ESB           | Розподіл логіки           | Центральна шина — bottleneck |
| **Microservices** | Багато дрібних незалежних сервісів | Гнучкість і масштабування | Складна координація          |

2. Назвіть переваги і недоліки мікросервісної архітектури.

	1. **Масштабованість**
	    - Можна масштабувати _окремі сервіси_, а не весь застосунок цілком.
	2. **Незалежний деплой**
	    - Оновлення одного сервісу _не зачіпає_ інші — легше викочувати фічі.
	3. **Технологічна гнучкість**
	    - Кожен сервіс можна писати на **різних мовах/фреймворках**, якщо потрібно.
	4. **Краща відмовостійкість**
	    - Якщо один сервіс падає, **вся система не обов’язково лягає** (за умови правильної побудови).
	5. **Простота розробки для команд**
	    - Команди можуть працювати **паралельно і незалежно** над різними сервісами.
	6. **Зручність CI/CD**
	    - Маленькі сервіси легше тестувати, релізити та обслуговувати.

3. Як відстежувати несправності в мікросервісах
	1. Централізоване логування
	2. Розподільне трасування(дозволяє простежити запит через усі сервіси, де він проходив)


### Деплоймент і процес розробки
4. Що таке CI (безперервна інтеграція)?
(Continue integration)- безперевна інтеграція, при кожній зміні коду, сам додаток перевіряється та сама білдиться.
5. Що таке CD
   Це продовження концепції CI, але має два варіанти розшифрування в залежності від того, до якого рівня автоматизовано доставку коду
   

![[Screenshot 2025-10-17 at 5.11.44 PM.png]]

6. У чому різниця між blue/green розгортанням і rolling розгортанням.![[Screenshot 2025-10-17 at 5.18.26 PM.png]]



### System Design
7. Що таке теорема CAP?
	**Теорема CAP** (також **теорема Брюера**) — це фундаментальний принцип у розподілених системах, який стверджує, що **будь-яка розподілена система не може одночасно повністю забезпечити всі три властивості**: